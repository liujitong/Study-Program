

# 线性表

## 什么是线性表

线性表一般是由相同的数据类型的元素构成的有限序列，此为线性表，但如果里面没有元素，则称之为空表。

线性表的每个数据的类型都是相同的，我们，每个元素都应有其前后的对应关系，当然，第一个数据没有前面的元素，最后一个没有后面的数据。

线性表的操作也很简单，`创建一个线性表`、`销毁一个线性表`、`将线性表置空`、`判断线性表是否是空的`、`线性表元素的个数`、`返回表中第几个元素的值`、`返回第一个与传入值相同的值（查找）`、`返回他的（后继）下一个值（除最后一个）`、`返回他的（前驱）前一个（除第一个）`、`在某个位置插入一个值`、`删除一个值`、`遍历这个表`

在不同的教材中其给出的操作是不同的，但是基础操作例如：初始化，删除，置空，插入值，返回值，遍历等，都是不可缺少的，通过组合基本的操作来实现自定义的操作。

## 线性表的顺序存储结构

### 顺序存储结构的定义和地址

顺序存储结构是一种用连续地址的存储单元存储线性表的数据元素，既然地址是连续的，那么其必然有一个最大值，这跟一维数组很相似

```c
#define MAXSIZE 20
typedef struct
{
    int data[MAXSIZE];//此处的int 可以换成任意一种数据类型
    int length;
}List;//(线性表)
```

由此我们能看到，数组data是存储数据的存储位置，他有一个最大的存储容量`MAX=20`，一个数据用来记录这个表的长度。

这里有个地方就是MAX是指的是这个数组所占空间长度为20，length指的是有数据的长度，也就是表的长度。

对于线性表他的物理地址一般是相邻的，可以计算其存储位置：
如果每个元素需要n个存储单元，以第一个数据所在位置的存储地址为存储起始位置，则第i+1个元素的地址和第i个元素的存储位置满足下列关系：（注：`LOC`函数指返回此数据的存储位置的函数）
$$
LOC(a_{i+1})=LOC(a_i)+n
$$
类比推算出：
$$
LOC(a_i)=LOC(a_1)+(i-1)*n
$$
通过这个公式可以得知，可以随意算出任一位置的地址，他们都是相同的时间，所以存入和取出数据的时间都是常数的，复杂度即为O(1)，通常也叫**随机存取结构**。

### 顺序存储结构操作的实现

说明：尽量使用C++，同时应对中文支持较好，因为`bool`是C++中的一种数据类型，当然你也可以像大多数书中所写的那样,使用C语言:

```c
#define OK 1
#define ERROR 0
typedef int Status;
//之后把所有bool的地方改成Status,return的值分别为OK 和 ERROR
```
开始前的准备

```c++
//头文件
#include<iostream>
//我们把自定义数据类型设置为int 
#define 自定义数据类型 int
//顺序表的定义
#define MAXSIZE 20
typedef struct
{
    int data[MAXSIZE];//此处的int 可以换成任意一种数据类型
    int length;
}List;//(线性表)
```

获取元素

```c++
//获取元素
bool GetElem(List L,int i,自定义数据类型 e)//此处的e代表我要返回的值，数据类型需要自己去改变
{
    if(L.length==0||i<1||i>L.length) return false;
    *e=L.data[i-1];//这里减一的原因我i传入的应该从1开始计数，而不是像数组一样从0开始计数
    return true;
}//代码用到了Bool类型判断这个函数是否能正常运行
```

插入操作

```c++
//插入操作
 bool ListInsert(List *L,int i,自定义数据类型 e)//e还是这个线性表的数据类型
 {
     if(L->length==MAXSIZE) return false;//表示表满了，应该返回一个false
     if(i<1||i>L->length+1) return false;//此举判断i是否符合插入要求
     if(i<=L->length)
     {
         for(int k=L->length-1;k>=i-1;k++)
         {
             L->data[k+1]=L->data[k];//转移哦
         }
    }
     L->data[i-1]=e;
     L->length++;
     return true;
 }
```

查找操作

```c++
//查找
int LOCATE(List L,自定义数据类型 e)
{
    for(int i=0;i<L.length;i++)
    {
        if(L.data[i]==e) return i+1;
    }
    return 0;//没找到    
}
```

删除操作

```c++
//删除操作
bool ListDelete(List *L,int i)
{
    //在顺序表L中删除第i个元素，i值的合法范围是1≤i≤L.length 
    if((i<1)||(i>L.length)) return false; //i值不合法 
    for(j=i;j<=L.length-1;j++) L.data[j-1]=L.data[j];
    //被删除元素之后的元素前移
    L.length--; 
    return OK;
}
```

### 顺序存储结构操作的代码时间复杂度分析

查找代码：

查找用`ASL`（平均查找长度）来进行讨论，假设pi 是查找第i个元素的概率，Ci 为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数，则在长度为n的线性表中，查找成功时的平均查找长度为:
$$
ASL=\sum_{i=1}^0p_iC_i
$$
假设每个元素被找到的概率为相同的：
$$
p_i=\frac{1}{n}
$$
那么可以简化成：
$$
ASL=\frac{1}{n}\sum_{i=1}^0i=\frac{n+1}{2}
$$
故顺序表按值查找算法的平均时间复杂度为O(n)。

插入：

假设pi 是在第i个元素之前插入一个元素的概率，Einsert为长度为n的线性表插入一个元素所需移动元素次数的期望值（平均次数），则有：
$$
E_{insert}=\sum^{n+1}_{i=1}p_i(n-i+1)
$$
还是令，每个位置插入是等概率的p=1/(n+1)

则：
$$
E_{insert}=\frac{1}{n+1}\sum^{n+1}_{i=1}(n-i+1)=\frac{n}{2}
$$
所以，插入算法的平均复杂度为O(n)。

删除：

删除和插入都是相似的都在于其时间都在移动元素之上，同理假设所有位置删除的概率为相同，p=1/n，则：
$$
E_{delete}=\frac{1}{n}\sum^n_{i=1}(n-i)=\frac{n-1}{2}
$$
因此啊，时间复杂度还是O(n)。

## 线性表的链式存储结构

### 单链表

线性表的链式存储结构特点是：用一组任意的存储单元来存储线性表的元素（**区别于线性表，这组空间可连续，也可不连续**），所以，要表示这个元素和他后一个元素之间有挂你先，除了存储他本身的数据外，我们还需要存储一个指示他的后继的信息。这两部本我们称之其为**节点**，它包括两个域，他存储数据元素信息的域称之为数据域，存储他的后继位置的域称之为指针域，指针域存储的信息乘坐指针或者链。若干个节点链接成为一个链表，则可称之其为线性表的链式存储结构，又因为只包含一个指针域，又称之其为线性链表或单链表。

也就是说啊，这个链式存储结构包含一个数据和一个指向下一个元素的指针，所以，用C/C++的想法来写如下:

```c++
typedef struct LNode{
    Elemtype data;//数据域，自定义数据类型
    struct LNode *next;//指针域，同时为了保证C语言同样能运行，要声明LNode是一个结构体
}LNode, *LinkList;

```

同时，为了方便，单链表一般会引入一个头节点，其Data不赋值，他的next指向首元结点（就是第一个有数据的结点）。

