# 类和对象

C++具有面向对象的三大特性：封装，继承，多态。C++认为万事万物都是对象，都具有其行为和属性。任何事物都可以定义属性和行为，那么根据这个特点，我们可以按照以下方法定义。

## 封装

用以下语句完成封装：`class {访问权限: 行为/属性};`

封装可以把生活中的事物，用C++抽象出来，写出其属性和行为。并且可以用访问权限加以权限控制{`private`,`protected`,`public`}。

例如以下代码

```C++
class Circle
{
    public:
    int r;//半径
    int ZC;//周长
    private:
    protected:
}
```

在C++中我们把通过一个类创建一个具体的对象的过程叫做实例化。

三种权限在使用过程中分别发挥这不同的作用，譬如说：public权限无论类的内外均有权访问，protected和private在类外无权访问。后两者区别在继承中会有不同。

类比C语言中的struct（结构体），其和class不同的是默认访问权限不同，struct默认为public，class默认为private。

## 构造函数和析构函数

对于对象而言，初始化和格式化是个非常重要的安全问题，在当今这个对于保护个人隐私非常重要的时代，我们有必要学习一下（无端联想）。

C++语言利用构造函数的析构函数来解决上述问题，这两种函数在没有我们定义的时候会由编译器自动调用，完成初始化和清理工作。

对象的初始化和清理工作是必须要做的事情，如果我们没有提供构造和析构函数，编译器会提供这两个函数为空实现。

- 构造函数：在创建对象的时候自动调用的函数。
- 析构函数：在对象被销毁前自动调用，执行一些清理工作。

构造函数语法： `类名() {}`

- 可以有参数，不写void，没有返回值，函数名和类名相同。

析构函数语法：`~类名() {}`

- 不可以有参数，不写void，没有返回值，函数名和类名相同。

以下是代码示例和运行结果

```C++
//1-1
#include<iostream>
using namespace std;

class Example_e
{
    public:
    Example_e()//构造函数
    {
        cout<<"构造函数调用"<<endl;
    }
    ~Example_e()//析构函数
    {
        cout<<"析构函数调用"<<endl;
    }
};
void example01()
{
    Example_e ex1;
}
int  main()
{
    example01();
    return 0;
}
```

运行结果:

![教程1-1](../../%E5%9B%BE%E5%BA%8A/%E6%95%99%E7%A8%8B1-1.png)

由于ex1是局部变量存放于栈区，在调用结束后就会被自动释放，所以，构造函数和析构函数都被调用了。

### 构造函数的分类及调用

构造函数分为有参构造，无参构造，普通构造，拷贝构造（复制构造也对）。

在定义构造函数的时候有参数就叫做有参构造。

有以下代码：

```C++
//1-2
#include<iostream>
using namespace std;
class example
{
    public:
    example(int a)
    {
        cout<<"现在是有参调用"<<endl;
    }
    example()
    {
        cout<<"现在是无参调用"<<endl;
    }
    //拷贝构造函数
    example (const example &xx)
    {
        cout << "拷贝构造函数!" << endl;
    }
    //析构函数
    ~example() 
    {
        cout << "析构函数!" << endl;
    }
};

void example01()
{
    cout<<"现在调用无参构造函数"<<endl;
    example exp1;
    cout<<"调用完毕1"<<endl;
}
void example02()
{
    cout<<"现在调用有参构造函数"<<endl;
    //第一种调用方式
    example exp2(10);
    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
    //example exp2();
    cout<<"完毕2"<<endl;
    //第二种调用方法
    example exp3 = example(10);
    cout<<"完毕3"<<endl;
    example exp4 = example(exp2);
    //2.3 隐式转换法
    example p4 = 10; // example p4 = example(10); 
    example p5 = p4; // example p5 = example (p4); 
    cout<<"完毕4"<<endl;
    //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
    //example p5(p4);
}
int main()
{
    example01();
    example02();
    return 0;
}
```

运行结果一目了然:
![教程1-2](../../%E5%9B%BE%E5%BA%8A/%E6%95%99%E7%A8%8B1-2.png)

一行一行读下去，自然就懂了，不懂的话，欢迎Github提交一个issue
