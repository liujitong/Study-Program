发信人: newcomers (新手上路), 信区: 
标  题: 软件工程2003
发信站:  (Mon Dec 22 13:32:05 2003), 转信

一、单项选择题。(10)
        在面向对象方法中，对象可看成是属性(数据)以及这些属性上的专用操作
的封装体。封装是一种(A)技术，封装的目的是使对象的(B)分离。
        类是一组具有相同属性和相同操作的对象的集合，类中的每个对象都是这
个类的一个(C)。类之间共享属性和操作的机制称为(D)。一个对象通过发送(E)来
请求另一个对象为其服务。
供选择的答案
A       1 组装 2 产品化 3 固化 4 信息隐蔽
B       1 定义和实现 2 设计和测试 3 设计和实现 4 分析和定义
C       1 例证 2 用况 3 实例 4 例外
D       1 多态性 2 动态绑定 3 静态绑定 4 继承
E       1 调用语句 2 消息 3 命令 4 口令

二、单项选择题。(10)
        Rational统一过程是(A)驱动的、软件(B)为中心的、迭代和增量的过程。
RUP是一个过程产品，软件过程也是(C)。每次迭代时过程的生存周期分为四个阶段，
包括初始、(D)、构造和发布。在RUP中用工作流来描述生成结果的(E)序列，包括业
务建模、需求、分析和设计、实现、测试、实施、配置和变更管理、项目管理、环
境等9个工作流。
供选择的答案
A       1 构件 2 用况 3 需求 4 用户
B       1 模型 2 需求 3 架构 4 程序
C       1 程序 2 算法 3 软件 4 结构
D       1 领域分析 2 需求获取 3 建模 4 细化
E       1 任务 2 动作 3 指令 4 活动

三、判断正误。(10)
1、UML语言与Rational统一开发过程都是Booch等人提出来的，它们在软件建模过
程中是相互参照，密不可分的。
2、使用用况模型可以描述软件系统的各种功能需求和非功能需求。
3、UML使用类图描述各个对象及其相互关系，即对象间的静态结构，使用对象图描
述各个对象实例间的动态结构。
4、在建立UML模型时，可以使用顺序图（也称时序图）描述为完成某一活动，各个
参与对象之间如何协同工作，事件如何识别及响应的。
5、在描述某一活动的情景时，使用顺序图和协作图都可以，不必都画出。
6、UML的活动图可以描述工作流，它起到数据流图的作用。
7、在用UML建立的模块图中特别描述了“接口”，其作用是考虑数据封装，将使用
与实现分离。
8、系统中使用状态图描述每一个对象的个体行为，因此对所有的对象都应画出它
的状态图。以全面刻画系统所涉及的实体。
9、使用用况图描述参与者（外部实体）和用况（系统）的交互时，可以使用事件
序列（情景）描述交互的细节。
10、使用UML建立系统的模型有5个视图，其中核心的视图是用况视图。

四、简做题。(10)
        将下面的DFD转换为软件结构图。
主图
                       ╭─╮                      
                    w3 │C │ w4                   
   w1╭─╮  w2╭─╮↗╰─╯↘╭─╮  w6╭─╮w7  
 ─→│A │─→│B │────→│D │─→│E │─→
     ╰─╯    ╰─╯    w5    ╰─╯    ╰─╯    

子图A
              ╭─╮              
          s1↗│X │╲s4          
          ╱  ╰─╯  ↘          
  w1╭─╮⊕s2╭─╮ s5 ╭─╮w2  
─→│K │─→│Y │─→│L │─→
    ╰─╯⊕  ╰─╯    ╰─╯    
          ╲s3╭─╮s6↗          
            ↘│Z │╱            
              ╰─╯              
五、简做题(20)
        下面是两个程序流程图，试分别用无GOTO语句的N-S图表示之，并计算它
们的McCabe复杂性度量（设每个判断内都是单个条件）。
        (因为不好画，所以判断语句我就不用菱形表示了，大家凑活着看吧。)
     ╭───╮                    ╭───╮                  
     │ start│                    │ start│                  
     ╰─┬─╯                    ╰─┬─╯                  
       ┌┴┐                        ┌┴┐                    
       │A │                        │A │          ┌─┐    
       └┬┘                        └┬┘  ┌──→┤C │    
         ├←───┐                ┌┴┐T │      └┬┘    
    T  ┌┴┐      │                │P ├─┘     F┌┴┐T   
   ┌─┤P │      │                └┬┘        ┌┤R ├┐  
   │  └┬┘      │                 F├←─┐    ↓└─┘↓  
   │    │F       │                ┌┴┐  │  ┌┴┐  ┌┴┐
   │  ┌┴┐T   ┌┴┐              │B │  │  │D │  │E │
   │  │Q ├─→┤B │              └┬┘  │  └┬┘  └┬┘
   │  └┬┘    └─┘            F ┌┴┐  └──┘      │  
   └─→┤F                     ┌─┤Q │                │  
      T┌┴┐F                   │  └┬┘                │  
   ┌─┤R ├─┐                │    │T                 │  
 ┌┴┐└─┘┌┴┐              │  ┌┴┐                │  
 │C │      │D │              │  │F │                │  
 └┬┘      └┬┘              │  └┬┘                │  
   └──┬──┘                └─→┼←────────┘  
     ╭─┴─╮                    ╭─┴─╮                  
     │ end  │                    │ end  │                  
     ╰───╯                    ╰───╯                  

六、单项选择题。(10)
        软件测试通常可分为单元测试、集成测试、确认测试和系统测试，其中
确认测试主要用于发现(A)阶段的错误。在集成测试时，通常可采用自顶向下增
量式集成和自底向上增量式集成。在自底向上增量式集成时，对每个被集成的模
块(B)。对那些为众多用户开发的软件(如操作系统、编译程序)，通常还要进行
Alpha测试和Beta测试，以发现可能只有最终用户才能发现的错误。其中，Alpha
测试是指最终用户在(C)的情况下所进行的测试，Beta是指最终用户在(D)的情况
下所进行的测试。在软件维护阶段，当修改软件后，除了进行常规的测试外，
还应进行(E)测试。
A       1 需求分析 2 概要设计 3 详细设计 4 编码
B       1 不必设计驱动模块和桩模块
        2 不必设计驱动模块，但要设计桩模块
        3 要设计驱动模块，但不必设计桩模块
        4 要设计驱动模块和桩模块
C       1 开发环境下，开发人员不在场
        2 开发环境下，开发人员在场
        3 用户的实际使用环境下，开发人员不在场
        4 用户的实际使用环境下，开发人员在场
D       1 开发环境下，开发人员不在场
        2 开发环境下，开发人员在场
        3 用户的实际使用环境下，开发人员不在场
        4 用户的实际使用环境下，开发人员在场
E       1 恢复 2 强度 3 安装 4 回归

七、测试设计题。(20)
        根据下面给出的程序描述，解答下列问题:
        (1)画出该程序的程序流程图。(10)
        (2)按照语句覆盖的覆盖准则，设计测试用例。(10)
BEGIN
  输入一元二次方程的二次项系数A、一次项系项B和常数项C；
  为根变量root1和root2赋表明无“实数根”的初值；
  if(A==0且B<>0)
    { root1=-C/B; root2=-C/B; };
  if(A<>0且B==0)
    if(-C/A>=0)
      { root1=SQR(-C/A); root2=-SQR(-C/A);};
      /*算符SQR表示开平方*/
  if(A<>0且B<>0)
    if(B^2-4AC>=0){
      root1=(-B+SQR(B^2-4AC))/(2A);
      root2=(-B-SQR(B^2-4AC))/(2A);
    };
    else 输出“此方程无实根”；
  输出root1和root2的值
END

八、计算。(关于软件可靠性，20分)
        (1)已知Ns=10，ns=2，n=160，IT=10^5，K=200。如果通过测试一段时间
t后，发现并改正的固有错误个数为Ec(t)=795。求ET和MTTF；
        (2)若把(1)中的MTTF再提高4倍，应至少再排除多少个固有错误？
--
[0m〾⿰⿱⿲⿳⿴⿵⿶⿷⿸⿹⿺⿻〾⿰⿱⿲⿳⿴⿵[1m一[0m⿷⿸⿹⿺⿻〾⿰⿱⿲⿳⿴⿵⿶⿷⿸⿹⿺[0m
⿶⿷[1m長[0m⿹⿺⿻[1m芳[0m⿰[1m晚[0m⿴⿳⿴[1m夕[0m⿵[1m天[0m⿸⿹⿺[1m知[0m⿻[1m觚[0m⿱[1m今[0m⿳⿴⿵⿶⿷⿸⿹⿺⿻〾⿰⿱⿲⿳⿴[0m
⿺⿻[1m庭[0m⿰[1m古[0m⿶[1m草[0m⿴[1m風[0m⿳[1m笛[0m⿲[1m陽[0m⿴[1m之[0m〾⿹⿱[1m交[0m⿺[1m濁[0m⿸[1m宵[0m⿷⿸⿹⿺⿻〾⿰⿶[1;31m╭━─╮[0m⿶⿷⿸[0m
⿲⿳[1m外[0m⿵[1m道[0m⿵[1m碧[0m⿹[1m拂[0m〾[1m聲[0m⿱[1m山[0m⿷[1m涯[0m⿴[1m地[0m⿶[1m半[0m〾[1m酒[0m⿹[1m別[0m〾⿰⿱⿲⿳⿴⿵⿸[1;31m┊鳳凰┆[0m⿻〾⿰[0m
⿴⿵⿲⿷[1m邊[0m⿰[1m連[0m⿻[1m柳[0m⿻[1m殘[0m⿳[1m外[0m⿶⿵⿶[1m之[0m⿸[1m零[0m⿰[1m盡[0m⿻[1m夢[0m⿱⿲⿳⿴⿵⿶⿷〾[1;31m│花開┋[0m〾⿰⿱[0m
⿸⿹⿳⿻〾〾[1m天[0m⿲⿻⿱⿺⿲[1m山[0m⿸⿹⿺[1m角[0m〾[1m落[0m⿷[1m余[0m〾[1m寒[0m⿵⿶⿷⿸⿹⿺⿻⿻[1;31m╰┈┅╯[0m⿳⿴⿵[0m[B[80D⿱⿸⿵⿺⿻⿱⿺⿱〾⿰⿴⿰⿶⿷⿸⿹⿺⿻〾⿶[1m歡[0m⿵⿰⿴⿵⿶⿷⿸⿹⿺⿱⿲⿳⿴⿸⿻〾⿵[m


[36m※ 修改:·newcomers 于 Dec 22 16:06:30 修改本文·[FROM: 219.224.140.110][m
[m[1;37m※ 来源:· bbs.net9.org·[FROM: 219.224.140.110][m
