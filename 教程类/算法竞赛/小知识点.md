# 小知识点

## 位运算

### 按位与运算符（&）

参加运算的两个数，按二进制位进行“与”运算。

运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）

即 0 & 0= 0 ，0 & 1= 0，1 & 0= 0， 1 & 1= 1。

例：3 &5 即 00000011 & 00000101 = 00000001 ，所以 3 & 5的值为1。

### 按位或运算符（|）

参加运算的两个数，按二进制位进行“或”运算。

运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。

即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。

例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

### 异或运算符（^）

参加运算的两个数，按二进制位进行“异或”运算。

运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。

例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。

### 示例代码

318.最大单词长度乘积

给你一个字符串数组 `words` ，找出并返回 `length(words[i]) * length(words[j])` 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 `0` 。

**示例 1：**

```exp
输入：words = ["abcw","baz","foo","bar","xtfn","abcdef"]
输出：16 
解释：这两个单词为 "abcw", "xtfn"。
```

**示例 2：**

```exp
输入：words = ["a","ab","abc","d","cd","bcd","abcd"]
输出：4 
解释：这两个单词为 "ab", "cd"。
```

**示例 3：**

```exp
输入：words = ["a","aa","aaa","aaaa"]
输出：0 
解释：不存在这样的两个单词。
```

**提示：**

- `2 <= words.length <= 1000`
- `1 <= words[i].length <= 1000`
- `words[i]` 仅包含小写字母

```cpp
class Solution {
public:
    int maxProduct(vector<string>& words) {
        int n=words.size();
        int mask[1000]={0};

        int max1=0;
        for(int i=0;i<words.size();i++)
        {
           for (char& c : words[i])
            {
                mask[i]|=(1<<(c-'a'));//设置每一个字母的存在关系，加或的原因是，保留之前的遍历
            }
            for(int z=0;z<i;z++)
            {
                if((mask[i]&mask[z])==0)//按位与，如果没重复，1&0,0&1,会返回0，就代表着没有重复的字母
                {
                    max1=max(max1,(int)(words[i].length()*words[z].length()));
                }
            }
        }
        return max1;
    }
};
```

位运算示例代码（ [Leetcode T318 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/)）
