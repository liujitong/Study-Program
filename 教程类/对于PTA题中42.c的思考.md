# 对于PTA第42题的思考

## 题目

这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

输入格式：
输入在一行中给出一个不以5结尾的正奇数x（<1000）。

输出格式：
在一行中输出相应的最小的s和n，其间以1个空格分隔。

输入样例：

```in
31
```

输出样例：

```out
3584229390681 15
```

|要求|要求|
|---|---|
|代码长度限制|16 KB|
|时间限制|400 ms|
|内存限制|64 MB|

先用正常的思路解决：

```c
#include<stdio.h>
#include<math.h>//我们可能会遇到pow函数，所以提前声明math函数
int main()
{
    int x;//用户输入数
    unsigned long long s;//这个数乘以用户输入数等于一个光棍数
    unsigned long long ggs=0;//光棍数
    int n=1;//位数
    scanf("%d",&x);
    for(n=1;;n++)
    {
        ggs=ggs+(long long int)(pow(10.0,1.0*(n-1)));
        if(ggs%x==0)
        {
            s=ggs/x;
            break;
        }
    }
    printf("%llu %d",s,n);
}
```

但是呢用例二，用例三超时了。
所以显然这道题并不适用于循环解决这个问题。
我们可以用手算除式的方法进行计算。
思路就是模拟手算除法的过程，如下图所示（来源于CSDN帖子）：
![思路](https://img-blog.csdn.net/20180926165751540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvYl9feXVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
代码如下：

```c
#include<stdio.h>

int main()
{
    int x;//用户输入数
    int n;//位数
    int s=0;
    scanf("%d",&x);
    int t=x;//确定好位数
    for(n=0;x>s;n++)//计算位数
    {
        s=s*10+1;
    }
    for(;;)
    { 
        printf("%d",s/x);//输出商
        s=s%x;//保存余数
        if(s==0) break;//余数为零跳出循环
        s=s*10+1;//除式
        n++;
    }
 printf(" %d",n);
 return 0;
}
```
